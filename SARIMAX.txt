import warnings
from statsmodels.tools.sm_exceptions import ConvergenceWarning
warnings.simplefilter("ignore", ConvergenceWarning)
warnings.simplefilter("ignore", FutureWarning)
warnings.simplefilter("ignore", UserWarning)
warnings.simplefilter("ignore", RuntimeWarning)

from flask import Flask, jsonify
from flask_cors import CORS
import pandas as pd
import numpy as np
import statsmodels.api as sm
import os

app = Flask(__name__)
CORS(app)

df = driver_df = forecast_df = comparison_df = None

DATA_FILES = {
    "tree": "Annual_Tree_Cover_Analysis_ha.csv",
    "agri": "agriculture_ha.csv",
    "log": "log_production.csv",
    "urban": "urbanization_percentage.csv",
    "roads": "national_roads.csv",
    "actual_tree": "Actual_Tree_Cover.csv"
}

def load_csv_safe(path):
    if os.path.exists(path):
        return pd.read_csv(path)
    return pd.DataFrame()

def prepare_data():
    global df, driver_df, forecast_df, comparison_df

    # Load CSVs
    tree = load_csv_safe(DATA_FILES["tree"])
    agri = load_csv_safe(DATA_FILES["agri"])
    log = load_csv_safe(DATA_FILES["log"])
    urban = load_csv_safe(DATA_FILES["urban"])
    roads = load_csv_safe(DATA_FILES["roads"])
    actual_tree = load_csv_safe(DATA_FILES["actual_tree"])

    # Fix missing Region in roads
    if "Region" not in roads.columns:
        all_regions = tree["Region"].unique()
        roads = roads.assign(key=1).merge(pd.DataFrame({"Region": all_regions, "key":1}), on="key").drop("key", axis=1)

    # Merge datasets
    df = tree.merge(agri, on=["Region","Year"], how="left")\
        .merge(log, on=["Region","Year"], how="left")\
        .merge(urban, on=["Region","Year"], how="left")\
        .merge(roads, on=["Region","Year"], how="left")

    df = df.rename(columns={
        "tree_cover_ha": "Tree_Cover",
        "extrapolated_urbanization_percentage": "Urbanization",
        "harvested_area_ha": "Agriculture",
        "log_production_cbm": "Logging",
        "Total_km": "Roads_km"
    })

    regions = df["Region"].unique()
    forecast_years = [2021,2022,2023,2024,2025]

    driver_rows = []
    forecast_rows = []
    comparison_rows = []

    print("\n=== Processing Regions and Calculating Forecasts ===")
    for region in regions:
        reg_df = df[df["Region"]==region].sort_values("Year")
        exog_vars = ["Agriculture","Logging","Urbanization","Roads_km"]

        # Linear Regression for driver importance
        X = sm.add_constant(reg_df[exog_vars])
        y = reg_df["Tree_Cover"]
        lr_model = sm.OLS(y,X).fit()
        for var in lr_model.params.index:
            driver_rows.append([region,var,lr_model.params[var],lr_model.pvalues[var]])

        # SARIMAX forecast
        exog = reg_df[exog_vars]
        sarimax_fit = sm.tsa.SARIMAX(reg_df["Tree_Cover"], order=(1,1,1), seasonal_order=(0,0,0,0), exog=exog).fit(disp=False)

        forecast_exog = np.array([
            np.polyval(np.polyfit(np.arange(len(reg_df)), reg_df[var].values, 1),
                       np.arange(len(reg_df), len(reg_df)+len(forecast_years)))
            for var in exog_vars
        ]).T

        tree_forecast = sarimax_fit.get_forecast(steps=len(forecast_years), exog=forecast_exog)

        for i, year in enumerate(forecast_years):
            forecast_rows.append([region, year, tree_forecast.predicted_mean.iloc[i]])
            actual_row = actual_tree[(actual_tree["Region"]==region) & (actual_tree["Year"]==year)]
            if not actual_row.empty:
                actual_val = actual_row["tree_cover_ha"].values[0]
                sarimax_val = tree_forecast.predicted_mean.iloc[i]
                ae = abs(sarimax_val-actual_val)
                ape = (ae/actual_val)*100
                comparison_rows.append([region, year, actual_val, sarimax_val, ae, ape])

    driver_df = pd.DataFrame(driver_rows, columns=["Region","Driver","Coefficient","P-value"])
    forecast_df = pd.DataFrame(forecast_rows, columns=["Region","Year","SARIMAX_Forecast"])
    comparison_df = pd.DataFrame(comparison_rows, columns=["Region","Year","Actual","SARIMAX_Forecast","AE","APE"]).drop_duplicates(subset=["Region","Year"])

    # Print results to console
    print("\n=== Driver Importance (First 10 rows) ===")
    print(driver_df.head(10))
    print("\n=== Forecasts (First 10 rows) ===")
    print(forecast_df.head(10))
    print("\n=== Forecast vs Actual Comparison (First 10 rows) ===")
    print(comparison_df.head(10))
    print(f"\nOverall MAE: {comparison_df['AE'].mean():.2f}")
    print(f"Overall MAPE: {comparison_df['APE'].mean():.2f}%")
    print("=== Data preparation complete! ===\n")

# API Endpoints
@app.route("/api/drivers")
def api_drivers():
    return jsonify(driver_df.to_dict(orient="records"))

@app.route("/api/forecasts")
def api_forecasts():
    return jsonify(forecast_df.to_dict(orient="records"))

@app.route("/api/comparison")
def api_comparison():
    return jsonify(comparison_df.to_dict(orient="records"))

@app.route("/api/regions")
def api_regions():
    return jsonify(df["Region"].unique().tolist())

@app.route("/api/overview")
def api_overview():
    return jsonify({
        "overall_mae": float(comparison_df['AE'].mean()),
        "overall_mape": float(comparison_df['APE'].mean()),
        "total_regions": len(df["Region"].unique()),
        "forecast_years": forecast_df["Year"].unique().tolist()
    })

if __name__ == "__main__":
    prepare_data()
    port = int(os.environ.get("PORT", 5000))
    app.run(debug=False, host='0.0.0.0', port=port)
